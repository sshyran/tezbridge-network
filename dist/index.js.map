{"version":3,"sources":["types.js","util.js","PsddFKi3/api.js","external.js","index.js"],"names":["safeProp","x","props","result","prop","undefined","curr","shift","Object","Array","prop_index","parseInt","isNaN","checkProps","obj","cursor","filterHashUrl","indexOf","start","end","slice","length","OpStep","constructor","main_fn","next_nodes","run","args","apply","Promise","then","catch","err","Gets","fetch","custom","path","head","sub_path","hash","header","protocol","predecessor","balance","address","contract","contract_bytes","hash_url","storage_bytes","big_map_bytes","manager_key","counter","Posts","submit","pack_data","data_json","type_json","param","forge_operation","head_hash","ops","branch","contents","preapply_operation","signature","inject_operation","signed_op","Mixed","makeOperationBytes","op_params","counter_prev","source","reveal","params","public_key","kind","push","assign","manager_pkh","forEach","item","op","origination","transaction","destination","delegation","baker","toString","operation_hex","makeOriginationBytes","basic","op_param","makeTransactionBytes","makeMinFeeOperation","TBC","secret_key","key","crypto","getKeyFromSecretKey","fee","gas_limit","storage_limit","op_bytes_result","getPublicKey","local_hex","localop","forgeOperation","signOperation","preapplyed_result","gas_sum","content","index","metadata","operation_result","internal_operation_results","errors","JSON","stringify","consumed_gas","paid_storage_size_diff","originated_contracts","op_with_sig","codec","toHex","bs58checkDecode","Math","ceil","fee_left","consumption","final_op_result","final_local_hex","final_op_with_sig","final_preapplied","operation_contents","operation_with_sig","amount","managerPubkey","delegate","External","net_type","domain","spendable","url","operations","type","inner_op","tz1","tz","TezBridgeNetwork","RPCFn","process","env","NODE_ENV","data","method","resolve","reject","req","XMLHttpRequest","addEventListener","pe","status","parse","responseText","open","setRequestHeader","send","https","require","raw_url","parsed_url","options","hostname","port","headers","request","res","on","d","console","log","e","write","APIs","PsddFKi3","PsddFKi3_API","host","get","call","post","mixed","external","switchProtocol"],"mappings":"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","file":"index.js","sourceRoot":"../src","sourcesContent":["// @flow\n\nexport type TezJSON =\n| number\n| string\n| boolean\n| void\n| {[string]: TezJSON}\n| Array<TezJSON>\n\nexport function safeProp(x : TezJSON, ...props : Array<string | number>) {\n  let result = undefined\n\n  let prop\n  let curr = x\n  while (true) {\n    prop = props.shift()\n    if (prop === undefined)\n      break\n\n    if (curr instanceof Object && !(curr instanceof Array)) {\n      result = curr[prop]\n      curr = curr[prop]\n    } else if (curr instanceof Array) {\n      const prop_index = parseInt(prop)\n      if (isNaN(prop_index))\n        return undefined\n\n      result = curr[prop_index]\n      curr = curr[prop_index]\n    } else {\n      return undefined\n    }\n  }\n\n  return result\n}\n\nexport type RPCFunc = (url: string, data?: TezJSON, method: 'POST' | 'GET') => Promise<TezJSON>\nexport type GetRPCFunc = (url: string, data?: TezJSON) => Promise<TezJSON>\nexport type PostRPCFunc = (url: string, data: TezJSON) => Promise<TezJSON>\n","// @flow\n\nexport function checkProps(obj : Object, ...props : Array<string>) {\n  let prop = props.shift()\n  let cursor = obj\n  while (prop !== undefined) {\n    if (!(prop in cursor) || cursor[prop] === undefined)\n      throw `Property: ${prop} is not in the object`\n\n    prop = props.shift()\n    cursor = cursor[prop]\n  }\n}\n\nexport function filterHashUrl(x : string) {\n  if (x.indexOf('/') === -1)\n    throw \"The input hash_url should be in this format: `xx/xx/xx/xx/xx/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx`\"\n\n  const start = x[0] === '/' ? 1 : 0\n  const end = x.slice(-1) === '/' ? -1 : x.length\n\n  return x.slice(start, end)\n}\n\nexport class OpStep {\n  main_fn: any => any\n  next_nodes: Array<OpStep>\n\n  constructor(main_fn : any => any, ...next_nodes : Array<OpStep>) {\n    this.main_fn = main_fn\n    this.next_nodes = next_nodes\n  }\n\n  run(...args : Array<any>) {\n    const result = this.main_fn.apply(this, args)\n    if (typeof result === 'boolean') {\n      if (result) \n        return this.next_nodes[0] && this.next_nodes[0].run()\n      else\n        return this.next_nodes[1] && this.next_nodes[1].run()\n    }\n\n    if (result instanceof Promise) {\n      return result.then(x => this.next_nodes[0] && this.next_nodes[0].run(x))\n      .catch(err => {\n        throw `OpStep error caught: ${err}`\n      })\n    }\n  }\n}","// @flow\n\nimport type { GetRPCFunc, PostRPCFunc, TezJSON } from '../types'\nimport { safeProp } from '../types'\nimport { checkProps, filterHashUrl, OpStep } from '../util'\n\n\nexport class Gets {\n  fetch : GetRPCFunc\n\n  constructor(fetch : GetRPCFunc) {\n    this.fetch = fetch\n  }\n  custom(path : string) {\n    return this.fetch(path)\n  }\n  head(sub_path? : string) {\n    return this.fetch(`/chains/main/blocks/head/${sub_path || ''}`)\n  }\n  hash() {\n    return this.head('hash')\n  }\n  header() {\n    return this.head('header')\n  }\n  protocol() {\n    return this.header().then(x => safeProp(x, 'protocol'))\n  }\n  predecessor() {\n    return this.header().then(x => safeProp(x, 'predecessor'))\n  }\n  balance(address : string) {\n    return this.fetch(`/chains/main/blocks/head/context/contracts/${address}/balance`)\n  }\n  contract(address : string) {\n    return this.fetch(`/chains/main/blocks/head/context/contracts/${address}`)\n  }\n  contract_bytes(hash_url : string, sub_path? : string) {\n    const hash = filterHashUrl(hash_url)\n    return this.fetch(`/chains/main/blocks/head/context/raw/bytes/contracts/index/originated/${hash}${sub_path || ''}`)\n  }\n  storage_bytes(hash_url : string) {\n    return this.contract_bytes(hash_url, '/data/storage')\n  }\n  big_map_bytes(hash_url : string) {\n    return this.contract_bytes(hash_url, '/big_map')\n  }\n  manager_key(address : string) {\n    return this.fetch(`/chains/main/blocks/head/context/contracts/${address}/manager_key`)\n  }\n  counter(address : string) {\n    return this.fetch(`/chains/main/blocks/head/context/contracts/${address}/counter`)\n  }\n\n}\n\nexport class Posts {\n  submit : PostRPCFunc\n\n  constructor(submit : PostRPCFunc) {\n    this.submit = submit\n  }\n\n  pack_data(data_json : TezJSON, type_json : TezJSON) {\n    const param = {\"data\": data_json,\"type\":type_json, \"gas\": \"400000\"}\n    return this.submit(`/chains/main/blocks/head/helpers/scripts/pack_data`, param)\n               .then(x => safeProp(x, 'packed'))\n  }\n\n  forge_operation(head_hash : string, ops : TezJSON) {\n    const param = {\n      branch: head_hash,\n      contents: ops\n    }\n    return this.submit(`/chains/main/blocks/head/helpers/forge/operations`, param)\n  }\n\n  preapply_operation(head_hash : string, ops : TezJSON, protocol : string, signature : string) {\n    const param = {\n      branch: head_hash,\n      contents: ops,\n      protocol,\n      signature\n    }\n    return this.submit(`/chains/main/blocks/head/helpers/preapply/operations`, [param])\n  }\n\n  inject_operation(signed_op : string) {\n    return this.submit('/injection/operation', signed_op)\n  }\n}\n\n\nexport class Mixed {\n  fetch: Gets\n  submit: Posts\n\n  constructor(fetch: Gets, submit: Posts) {\n    this.fetch = fetch\n    this.submit = submit\n  }\n\n  static params = {\n    reveal(source: string, public_key: string, counter: string) {\n      return {\n        kind: 'reveal',\n        source,\n        fee: '1300',\n        gas_limit: '10000',\n        storage_limit: '0',\n        public_key,\n        counter\n      }\n    },\n    transaction(source: string, destination: string, counter: string) {\n      return {\n        kind: 'transaction',\n        source,\n        fee: '400000',\n        gas_limit: '400000',\n        storage_limit: '60000',\n        amount: '0',\n        counter,\n        destination,\n        // parameters?: $micheline.michelson_v1.expression\n      }\n    },\n    origination(source: string, manager_key: string, counter: string) {\n      return {\n        kind: 'origination',\n        source,\n        fee: '400000',\n        counter,\n        gas_limit: '400000',\n        storage_limit: '60000',\n        managerPubkey: manager_key,\n        balance: '0',\n        // \"spendable\"?: boolean,\n        // \"delegatable\"?: boolean,\n        // \"delegate\"?: $Signature.Public_key_hash,\n        // \"script\"?: $scripted.contracts\n      }\n    },\n    delegation(source: string, baker : string, counter : string) {\n      return {\n        counter,\n        delegate: baker,\n        fee: \"1420\",\n        gas_limit: \"10000\",\n        kind: \"delegation\",\n        source,\n        storage_limit: \"0\"\n      }\n    }\n  }\n\n  async makeOperationBytes(param: {\n    source : string,\n    public_key: string\n  }, op_params: Array<{\n    kind : 'reveal' | 'origination' | 'transaction' | 'delegation',\n    destination? : string,\n    baker? : string\n  }>) : Promise<any> {\n    const ops : Array<TezJSON> = []\n    const counter_prev = await this.fetch.counter(param.source)\n    const manager_key = await this.fetch.manager_key(param.source)\n\n    if (typeof counter_prev !== 'string')\n      throw 'Invalid counter'\n\n    let counter = parseInt(counter_prev) + 1 + ''\n\n    if (!safeProp(manager_key, 'key')) {\n      const reveal = Mixed.params.reveal(param.source, param.public_key, counter)\n\n      if (op_params.length && op_params[0].kind === 'reveal')\n        ops.push(Object.assign({}, reveal, op_params.shift()))\n      else\n        ops.push(reveal)\n\n      counter = parseInt(counter) + 1 + ''\n    }\n\n    const manager_pkh = safeProp(manager_key, 'manager')\n    if (typeof manager_pkh !== 'string')\n      throw 'Invalid manager public key hash'\n\n    op_params.forEach(item => {\n      const op = {\n        reveal: null,\n        origination: Object.assign(\n          {},\n          Mixed.params.origination(param.source, manager_pkh, counter),\n          item\n        ),\n        transaction: Object.assign(\n          {},\n          Mixed.params.transaction(param.source, item.destination || '', counter),\n          item\n        ),\n        delegation: Object.assign(\n          {},\n          Mixed.params.delegation(param.source, item.baker || '', counter)  \n        )\n      }[item.kind]\n\n      if (!op)\n        throw `Invalid t(${item.kind}) in makeOperationBytes`\n\n      ops.push(op)\n      counter = parseInt(counter) + 1 + ''\n    })\n\n    const head_hash = await this.fetch.hash()\n\n    if (!(typeof head_hash === 'string'))\n      throw `Error type for head_hash result: ${head_hash.toString()}`\n\n    const operation_hex = await this.submit.forge_operation(head_hash, ops)\n    const protocol = await this.fetch.protocol()\n\n    return {\n      protocol,\n      operation_hex,\n      branch: head_hash,\n      contents: ops\n    }\n  }\n\n  async makeOriginationBytes(basic : {\n    source : string,\n    public_key: string\n  }, op_param : Object) {\n    return this.makeOperationBytes({\n      source: basic.source,\n      public_key: basic.public_key\n    }, [Object.assign({\n      kind: 'origination'\n    }, op_param)])\n  }\n\n  async makeTransactionBytes(basic : {\n    source : string,\n    public_key: string\n  }, op_param : Object) {\n    return this.makeOperationBytes({\n      source: basic.source,\n      public_key: basic.public_key\n    }, [Object.assign({\n      kind: 'transaction'\n    }, op_param)])\n  }\n\n  async makeMinFeeOperation(TBC : any, source : string | null, secret_key : string, op_params : any) {\n    const key = TBC.crypto.getKeyFromSecretKey(secret_key)\n\n    op_params.forEach(op => {\n      delete op.fee\n      delete op.gas_limit\n      delete op.storage_limit\n    })\n\n    const op_bytes_result = await this.makeOperationBytes({\n      source: source || key.address,\n      public_key: key.getPublicKey()\n    }, op_params)\n\n    const ops = op_bytes_result.contents\n\n    const local_hex = TBC.localop.forgeOperation(op_bytes_result.contents, op_bytes_result.branch)\n    if (local_hex !== op_bytes_result.operation_hex) {\n      throw `Inconsistent forged bytes:\\nLocal(${local_hex})\\nRemote(${op_bytes_result.operation_hex})`\n    }\n\n    op_bytes_result.signature = TBC.crypto.signOperation(op_bytes_result.operation_hex, secret_key)\n    const preapplyed_result : any = await this.submit.preapply_operation(\n      op_bytes_result.branch, op_bytes_result.contents, op_bytes_result.protocol, op_bytes_result.signature)\n\n    if (!(preapplyed_result instanceof Array))\n      throw `Invalid preapplyed result: ${preapplyed_result}`\n\n    let gas_sum = 0\n    preapplyed_result[0].contents.forEach((content, index) => {\n      let gas_limit = 0\n      let storage_limit = 0\n\n      const result = content.metadata.operation_result\n      const internal_operation_results = content.metadata.internal_operation_results\n\n      if (internal_operation_results) {\n        internal_operation_results.forEach(op => {\n          if (op.result.errors)\n            throw `Internal operation errors:${JSON.stringify(op.result.errors, null, 2)}`\n\n          gas_limit += parseInt(op.result.consumed_gas)\n          if (op.result.paid_storage_size_diff)\n            storage_limit += parseInt(op.result.paid_storage_size_diff)\n          if (op.result.originated_contracts)\n            storage_limit += op.result.originated_contracts.length * 257\n        })\n      }\n\n      if (result.errors)\n        throw `Operation errors:${JSON.stringify(result.errors, null, 2)}` \n\n      gas_limit += parseInt(result.consumed_gas)\n      if (result.paid_storage_size_diff)\n        storage_limit += parseInt(result.paid_storage_size_diff)\n      if (result.originated_contracts)\n        storage_limit += result.originated_contracts.length * 257\n\n      ops[index].gas_limit = gas_limit + ''\n      ops[index].storage_limit = storage_limit + ''\n      ops[index].fee = '0'\n\n      gas_sum += parseInt(gas_limit)\n    })\n\n    const op_with_sig = op_bytes_result.operation_hex + TBC.codec.toHex(TBC.codec.bs58checkDecode(op_bytes_result.signature))\n    const fee = Math.ceil(100 + op_with_sig.length / 2 + 0.1 * gas_sum)\n\n    let fee_left = fee\n    ops.forEach(op => {\n      const consumption = fee_left <= 400000 ? fee_left : 400000\n      op.fee = consumption + ''\n      fee_left -= consumption\n    })\n    if (fee_left)\n      throw `Still need ${fee_left} fee to run the operation` \n\n    const final_op_result = await this.makeOperationBytes({\n      source: key.address,\n      public_key: key.getPublicKey()\n    }, ops)\n\n    const final_local_hex = TBC.localop.forgeOperation(final_op_result.contents, final_op_result.branch)\n    if (final_local_hex !== final_op_result.operation_hex) {\n      throw `Inconsistent final forged bytes:\\nLocal(${local_hex})\\nRemote(${final_op_result.operation_hex})`\n    }\n\n    final_op_result.signature = TBC.crypto.signOperation(final_op_result.operation_hex, secret_key)\n    const final_op_with_sig = final_op_result.operation_hex + TBC.codec.toHex(TBC.codec.bs58checkDecode(final_op_result.signature))\n    \n    const final_preapplied : any = await this.submit.preapply_operation(\n      final_op_result.branch, final_op_result.contents, final_op_result.protocol, final_op_result.signature)\n\n    if (!(final_preapplied instanceof Array))\n      throw `Invalid final preapplyed result: ${final_preapplied}`\n\n    const originated_contracts = []\n    final_preapplied[0].contents.forEach((content, index) => {\n      const result = content.metadata.operation_result\n      const internal_operation_results = content.metadata.internal_operation_results\n\n      if (internal_operation_results) {\n        internal_operation_results.forEach(op => {\n          if (op.result.errors)\n            throw `Final internal operation errors:${JSON.stringify(op.result.errors, null, 2)}` \n\n          if (op.result.originated_contracts)\n            originated_contracts.push(op.result.originated_contracts)\n        })\n      }\n\n      if (result.errors)\n        throw `Final operation errors:${JSON.stringify(result.errors, null, 2)}` \n\n      if (result.originated_contracts)\n        originated_contracts.push(result.originated_contracts)\n    })\n\n    return {\n      fee,\n      originated_contracts,\n      branch: final_op_result.branch,\n      operation_contents: final_op_result.contents,\n      operation_with_sig: final_op_with_sig\n    }\n  }\n}\n\nexport default { Gets, Posts, Mixed }","// @flow\nimport type { GetRPCFunc, PostRPCFunc, TezJSON } from './types'\n\nexport class External {\n  fetch: GetRPCFunc\n  net_type: 'mainnet' | 'alphanet'\n\n  constructor(fetch : GetRPCFunc, net_type : string) {\n    this.fetch = fetch\n    this.net_type = net_type === 'alphanet' ? net_type : 'mainnet'\n  }\n\n  domain() {\n    if (this.net_type === 'mainnet')\n      return 'https://api1.tzscan.io/v3'\n    else if (this.net_type === 'alphanet')\n      return 'https://api.alphanet.tzscan.io/v3'\n    else\n      throw 'The net type can only be mainnet or alphanet'\n  }\n\n  async originated_contracts(address : string, spendable : boolean = true) {\n    const url = this.domain() + `/operations/${address}?type=Origination`\n    const operations  = await this.fetch(url)\n    const result = []\n    if (operations instanceof Array) \n      operations.forEach(op => {\n        op.type.operations.forEach(inner_op => {\n          if (inner_op.spendable === spendable)\n            result.push(inner_op.tz1.tz)\n        })\n      })\n    else\n      throw 'Operations is invalid'\n\n    return result\n  }\n\n}","// @flow\n\nconst RPCFn = (() => {\n  if (process.env.NODE_ENV === 'browser') {\n    return (url, data, method) => {\n      return new Promise<TezJSON>((resolve, reject) => {\n        const req = new XMLHttpRequest()\n        req.addEventListener('load', (pe: ProgressEvent) => {\n          if (req.status === 200)\n            resolve(JSON.parse(req.responseText))\n          else\n            reject(req.responseText)\n        })\n        req.addEventListener('error', reject)\n        req.addEventListener('abort', reject)\n        req.open(method, url)\n        if (method === 'POST') {\n          req.setRequestHeader('Content-Type', 'application/json')\n        }\n        req.send(JSON.stringify(data))\n      })\n    }\n  } else {\n    const https = require('https')\n    const url = require('url')\n    return (raw_url: string, data?: TezJSON, method: 'POST' | 'GET') => {\n      return new Promise<TezJSON>((resolve, reject) => {\n        const parsed_url = url.parse(raw_url)\n        const options = {\n          hostname: parsed_url.hostname,\n          port: parsed_url.port,\n          path: parsed_url.path,\n          method,\n          headers: raw_url.indexOf('tzscan.io/v3') > -1 ? {} : {\n            'Content-Type': 'application/json'\n          }\n        }\n\n        const req = https.request(options, (res) => {\n          let data = ''\n          res.on('data', (d) => {\n            data += d.toString()\n          })\n\n          res.on('end', () => {\n            try {\n              resolve(JSON.parse(data))\n            } catch(err) {\n              console.log('\\x1b[31m%s\\x1b[0m','RPC result JSON.parse error: ', data)\n            }\n          })\n        })\n\n        req.on('error', (e) => {\n          reject(e)\n        })\n\n        if (method === 'POST') {\n          req.write(JSON.stringify(data))\n        }\n\n        req.end()\n      })\n    }\n  }\n})()\n\nimport PsddFKi3_API from './PsddFKi3/api'\nimport { External } from './external'\nimport type { RPCFunc, TezJSON } from './types'\n\nconst APIs = {\n  PsddFKi3: PsddFKi3_API\n}\n\nexport class TezBridgeNetwork {\n  host: string\n  RPCFn: RPCFunc\n  net_type: 'mainnet' | 'alphanet'\n  fetch: PsddFKi3_API.Gets\n  submit: PsddFKi3_API.Posts\n  mixed: PsddFKi3_API.Mixed\n  external: External\n\n  constructor(params : {\n    host: string, \n    protocol?: string,\n  }) {\n    if (!params.host)\n      throw \"Please set the host parameter\"\n\n    this.host = params.host\n    this.RPCFn = RPCFn\n    this.net_type = this.host.indexOf('alphanet') > -1 ? 'alphanet' : 'mainnet'\n\n    const protocol = params.protocol || 'PsddFKi3'\n\n    if (!(protocol in APIs)) {\n      throw `Protocol:${protocol} doesn't exist in protocols`\n    }\n\n    this.fetch = new APIs[protocol].Gets((url, data) => this.get.call(this, url, data))\n    this.submit = new APIs[protocol].Posts((url, data) => this.post.call(this, url, data))\n    this.mixed = new APIs[protocol].Mixed(this.fetch, this.submit)\n    this.external = new External((url, data) => this.RPCFn(url, data, 'GET'), this.net_type)\n  }\n\n  switchProtocol(protocol : string) {\n    if (!(protocol in APIs)) {\n      throw `Protocol:${protocol} doesn't exist in protocols`\n    }\n    \n    this.fetch = new APIs[protocol].Gets((url, data) => this.get.call(this, url, data))\n    this.submit = new APIs[protocol].Posts((url, data) => this.post.call(this, url, data))\n    this.mixed = new APIs[protocol].Mixed(this.fetch, this.submit)\n  }\n\n  get(url: string, data?: TezJSON) {\n    return this.RPCFn(this.host + url, data, 'GET')\n  }\n\n  post(url: string, data: TezJSON) {\n    return this.RPCFn(this.host + url, data, 'POST')\n  }\n}\n\nexport default TezBridgeNetwork"]}